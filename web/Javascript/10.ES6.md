# ES6

## 一、class定义类

> 构造函数形式创建 **类**，不仅仅和编写普通的函数过于相似，而且代码并不容易理解。 在ES6新的标准中使用了**class关键字**来直接定义类； 但是类本质上构造函数、原型链的语法糖而已；

### 1.类的声明

```javascript
// 类声明
class Person {
}
// 类表达式
var Student = class {
}

// 相似的如：
// 函数声明
function Parent() {
}
// 函数表达式
var son = function() {
}
```

### 2.constructor

> **constructor**方法(即**构造方法**)是类的默认方法，通过new生成对象时，自动调用该方法。

**注**：

* 每个类只能有**一个**构造函数，如果包含多个构造函数，那么会抛出异常；

* 一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加；

```javascript
class People {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}

var p1 = new People('颤三',19)
p1.eatting() // 颤三吃！
p1.running() // 颤三跑！
```

### 3.实例方法

> **class**中定义的**方法**，实际上都是定义在这个"类"的**prototype**上的。

```javascript
class People {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}

console.log(Object.getOwnPropertyDescriptors(People)); // 输出如下：
// {
//   length: { value: 2, writable: false, enumerable: false, configurable: true },
//   name: {
//     value: 'People',
//     writable: false,
//     enumerable: false,
//     configurable: true
//   },
//   prototype: {
//     value: {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }
console.log(Object.getOwnPropertyDescriptors(People.prototype)); // 输出如下：
// {
//   constructor: {
//     value: [class People],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   eatting: {
//     value: [Function: eatting],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   running: {
//     value: [Function: running],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
```

### 4.类的访问器方法

> 当调用**获取**或**设置**某个属性时，触发**get**或**set**函数里的函数体代码。

```javascript
class Abc {
  constructor(name) {
    this.name = name
  }

  set name(newName) {
    console.log("设置了这个属性name");
  }
  get name() {
    console.log("调用或获取了这个属性name");
    // return this.name
    return "获取" // get必须有返回值
  }
}
console.log(Abc.name); // Abc
```

### 5.类的静态方法

> 静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义.

```javascript
class Asd {
  constructor(asd) {
    this.asd = asd
  }
  
  haox() {
    console.log("不是静态方法不可以直接调用");
  }

  static create() {
    console.log("你调用了静态方法");
  }
}
Asd.create() // 你调用了静态方法
// Asd.haoX() // 报错，不是静态方法不能直接调用，需要new一个实例才能调用
var a1 = new Asd()
a1.haox() // 不是静态方法不可以直接调用
```

### 6.继承

> 通过**extends**关键字继承。

```javascript
class A {

}
class B extends A {
  
}
```

* 子类中新添加的方法是添加到了子类的原型对象上，并不是父类的远程对象上;

```javascript
class A {
  constructor(name,age) {
    this.name = name
    this.age = age
  }
  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}
class B extends A {
  constructor(name,age,height) {
    // this.name = name
    // this.age = age
    super(name,age) // 这里必须调用父类的构造器否则报错(派生类的构造函数必须包含 "super" 调用。)，同时可以避免代码冗余
    this.height = height

  }
  study() {
    console.log("study");
  }
}

// 子类中新添加的方法是添加到了子类的原型对象上，并不是父类的远程对象上
console.log(Object.getOwnPropertyDescriptors(B.prototype)); // 输出如下：
// {
//   constructor: {
//     value: [class B extends A],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   study: {
//     value: [Function: study],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
console.log(Object.getOwnPropertyDescriptors(A.prototype));  // 输出如下：
// {
//   constructor: {
//     value: [class A],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   eatting: {
//     value: [Function: eatting],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   running: {
//     value: [Function: running],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
```



### 7.super关键字

> * 可调用父类的构造函数；
> * 可调用父类上的方法