# ES6

## 一、class定义类

> 构造函数形式创建 **类**，不仅仅和编写普通的函数过于相似，而且代码并不容易理解。 在ES6新的标准中使用了**class关键字**来直接定义类； 但是类本质上构造函数、原型链的语法糖而已；

### 1.类的声明

```javascript
// 类声明
class Person {
}
// 类表达式
var Student = class {
}

// 相似的如：
// 函数声明
function Parent() {
}
// 函数表达式
var son = function() {
}
```

### 2.constructor

> **constructor**方法(即**构造方法**)是类的默认方法，通过new生成对象时，自动调用该方法。

**注**：

* 每个类只能有**一个**构造函数，如果包含多个构造函数，那么会抛出异常；

* 一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加；

```javascript
class People {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}

var p1 = new People('颤三',19)
p1.eatting() // 颤三吃！
p1.running() // 颤三跑！
```

### 3.实例方法

> **class**中定义的**方法**，实际上都是定义在这个"类"的**prototype**上的。

```javascript
class People {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}

console.log(Object.getOwnPropertyDescriptors(People)); // 输出如下：
// {
//   length: { value: 2, writable: false, enumerable: false, configurable: true },
//   name: {
//     value: 'People',
//     writable: false,
//     enumerable: false,
//     configurable: true
//   },
//   prototype: {
//     value: {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }
console.log(Object.getOwnPropertyDescriptors(People.prototype)); // 输出如下：
// {
//   constructor: {
//     value: [class People],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   eatting: {
//     value: [Function: eatting],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   running: {
//     value: [Function: running],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
```

### 4.类的访问器方法

> 当调用**获取**或**设置**某个属性时，触发**get**或**set**函数里的函数体代码。

```javascript
class Abc {
  constructor(name) {
    this.name = name
  }

  set name(newName) {
    console.log("设置了这个属性name");
  }
  get name() {
    console.log("调用或获取了这个属性name");
    // return this.name
    return "获取" // get必须有返回值
  }
}
console.log(Abc.name); // Abc
```

### 5.类的静态方法

> 静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义.

```javascript
class Asd {
  constructor(asd) {
    this.asd = asd
  }
  
  haox() {
    console.log("不是静态方法不可以直接调用");
  }

  static create() {
    console.log("你调用了静态方法");
  }
}
Asd.create() // 你调用了静态方法
// Asd.haoX() // 报错，不是静态方法不能直接调用，需要new一个实例才能调用
var a1 = new Asd()
a1.haox() // 不是静态方法不可以直接调用
```

### 6.继承

> 通过**extends**关键字继承。

```javascript
class A {

}
class B extends A {
  
}
```

* 子类中新添加的方法是添加到了子类的原型对象上，并不是父类的远程对象上;

```javascript
class A {
  constructor(name,age) {
    this.name = name
    this.age = age
  }
  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}
class B extends A {
  constructor(name,age,height) {
    // this.name = name
    // this.age = age
    super(name,age) // 这里必须调用父类的构造器否则报错(派生类的构造函数必须包含 "super" 调用。)，同时可以避免代码冗余
    this.height = height

  }
  study() {
    console.log("study");
  }
}

// 子类中新添加的方法是添加到了子类的原型对象上，并不是父类的远程对象上
console.log(Object.getOwnPropertyDescriptors(B.prototype)); // 输出如下：
// {
//   constructor: {
//     value: [class B extends A],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   study: {
//     value: [Function: study],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
console.log(Object.getOwnPropertyDescriptors(A.prototype));  // 输出如下：
// {
//   constructor: {
//     value: [class A],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   eatting: {
//     value: [Function: eatting],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   running: {
//     value: [Function: running],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
```



### 7.super关键字

> * 可调用父类的构造函数；
> * 可调用父类上的方法



## 二、字面量的增强

>  ES6中对 **对象**字面量 进行了增强;

### 1.属性的简写

### 2.方法的简写

### 3.计算属性名

```javascript
var age = 18
var obj1 = {
  // age : age
  age,    // 1.属性的简写

  // 2.方法名简写
  // foo: function() {

  // }
  foo() {  // 简写

  },

  // 3.计算属性
  [age + 123]: 'hhhhh',
  [age + '123']: 'hhhhh'
}

console.log(obj1);  // { '141': 'hhhhh', '18123': 'hhhhh', age: 18, foo: [Function: foo] }
```



## 三、解构赋值

### 1.数组的解构

```javascript
// 1.数组的解构
var names = ['agc', 'cag', 'asd']
var [item1, item2, item3] = names
console.log(item1,item2,item3); // agc cag asd

// 2.解构后面元素
var [, itema, itemb] = names
console.log(itema,itemb); // cag asd

// 3.解构出一个元素，后面的元素放到一个新数组中
var [itemx, ...newNames] = names
console.log(newNames); // [ 'cag', 'asd' ]

// 4.解构的默认值 (当解构的元素可能没有值时，可以设置一个默认值)
var [itema, itemb, itemc, itemd = 'aaa'] = names
console.log(itemd); // aaa
```

### 2.对象的解构

```javascript
var obj = {
  name: 'tjx',
  age: 39,
  height: 12,
  a: 12
}

// 1.对象的解构
var { namea, age, height } = obj
console.log(namea, age, height); // tjx 39 12

var { a } = obj
console.log(a); // 12

// 2.解构重命名
var {name: newName} = obj
console.log(newName); // tjx

// 3.解构重命名并给默认值
var { address: newAddress = "广州" } = obj  
console.log(newAddress); // 广州
```



## 四、var、const、let

> * **let和const**，是目前开发中推荐使用的；
>
> * 优先推荐使用const，这样可以保证数据的安全性不会被随意的篡改； 
> * 只有当明确知道一个变量后续会需要被重新赋值时，这个时候再使用let；

### 1.var

> * 作用域提升；
> * 函数有块级作用域，在函数中var变量属于该函数的局部变量；

### 2.const

> const关键字是constant的单词的缩写，表示常量、衡量的意思；
>
> 它表示保存的数据一旦被赋值，就不能被修改；
>
> 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容；

### 3.let

> 声明的变量具有块级作用域的特征；





## 五、模板字符串

### 1.基本使用

```javascript
let agea = 9
const info = `age: ${agea *2}`
console.log(info); // age: 18

function doubleAge() {
  return agea * 2
}
const infoa = `age: ${doubleAge()}`
console.log(infoa); // age: 18
```

### 2.标签模板字符串

```javascript
// 第一个参数依然是模板字符串中整个字符串，只是被切割成多块，放到了一个数组中
// 第二个参数是模块字符串中，第一个${}，一次类推
function foo(m, n, x) {
  console.log(m,n, x, '..........');
}
const named = 'tjx'
const aged = 13

// 通过模板标签调用函数
foo`Hello${named}, world${aged},!`  //  [ 'Hello', ', world', ',!' ] tjx 13 ..........
```



## 六、函数的参数

### 1.函数的默认参数

```javascript
// 1.函数默认参数
function foo(m = 'aaa', n = 'bb') {
  console.log(m,n);
}
foo() // aaa bb
foo('dfs','fds') // dfs fds

// 对象参数和默认参数以及解构
// 写法一：
function printInfo({name, age} = {name: 'tjc', age: 19}) {
  console.log(name,age);
}
printInfo() // tjc 19
printInfo({name: 'lobe', age: 90}) // lobe 90

// 写法二：
function printInfo({name = 'tjx', age = 19} = {}) {
  console.log(name,age);
}
```

### 2.函数的剩余参数

```javascript
function foo(m,n,...args) {
  console.log(m,n); // 1 2
  console.log(args);  // [ 3, 4, 5, 6, 7 ]
  console.log(arguments);  //  [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5, '5': 6, '6': 7 }
}
foo(1,2,3,4,5,6,7)
```

### 3.箭头函数的补充

> * 箭头函数没有**prototype**，不能通过new关键字创建箭头函数；
> * 箭头函数没有**this**以及**arguments**



## 七、展开运算符

```javascript
const nameg = ['asd', 'dfg', 'sdfg']
const nameh = 'tjx'
const infog = {name: 'tjx', age: 19}

// 1.函数调用时
function foo(x, y, z) {
  console.log(x,y,z);
}

foo(...nameg) // asd dfg sdfg
foo(...nameh) // t j x

// 2.构造数组时
const newNameg = [...nameg, ...nameh]
console.log(newNameg); // [ 'asd', 'dfg', 'sdfg', 't', 'j', 'x' ]

// 3.构造对象字面量时
const objh = {...infog, address: 'guand'}
console.log(objh); // { name: 'tjx', age: 19, address: 'guand' }
```



## 八、数值的表示

```javascript
const num1 = 100 // 十进制
const num2 = 0b100 // 二进制
const num3 = 0o100 // 八进制
const num4 = 0x100 // 十六进制

console.log(num1, num2, num3, num4); // 100 4 64 256

// 大的数值的连接符
const num = 10_000_000_000_000
console.log(num); // 10000000000000
```



