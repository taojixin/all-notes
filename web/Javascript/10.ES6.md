# ES6

## 一、class定义类

> 构造函数形式创建 **类**，不仅仅和编写普通的函数过于相似，而且代码并不容易理解。 在ES6新的标准中使用了**class关键字**来直接定义类； 但是类本质上构造函数、原型链的语法糖而已；

### 1.类的声明

```javascript
// 类声明
class Person {
}
// 类表达式
var Student = class {
}

// 相似的如：
// 函数声明
function Parent() {
}
// 函数表达式
var son = function() {
}
```

### 2.constructor

> **constructor**方法(即**构造方法**)是类的默认方法，通过new生成对象时，自动调用该方法。

**注**：

* 每个类只能有**一个**构造函数，如果包含多个构造函数，那么会抛出异常；

* 一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加；

```javascript
class People {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}

var p1 = new People('颤三',19)
p1.eatting() // 颤三吃！
p1.running() // 颤三跑！
```

### 3.实例方法

> **class**中定义的**方法**，实际上都是定义在这个"类"的**prototype**上的。

```javascript
class People {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}

console.log(Object.getOwnPropertyDescriptors(People)); // 输出如下：
// {
//   length: { value: 2, writable: false, enumerable: false, configurable: true },
//   name: {
//     value: 'People',
//     writable: false,
//     enumerable: false,
//     configurable: true
//   },
//   prototype: {
//     value: {},
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }
// }
console.log(Object.getOwnPropertyDescriptors(People.prototype)); // 输出如下：
// {
//   constructor: {
//     value: [class People],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   eatting: {
//     value: [Function: eatting],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   running: {
//     value: [Function: running],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
```

### 4.类的访问器方法

> 当调用**获取**或**设置**某个属性时，触发**get**或**set**函数里的函数体代码。

```javascript
class Abc {
  constructor(name) {
    this.name = name
  }

  set name(newName) {
    console.log("设置了这个属性name");
  }
  get name() {
    console.log("调用或获取了这个属性name");
    // return this.name
    return "获取" // get必须有返回值
  }
}
console.log(Abc.name); // Abc
```

### 5.类的静态方法

> 静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义.

```javascript
class Asd {
  constructor(asd) {
    this.asd = asd
  }
  
  haox() {
    console.log("不是静态方法不可以直接调用");
  }

  static create() {
    console.log("你调用了静态方法");
  }
}
Asd.create() // 你调用了静态方法
// Asd.haoX() // 报错，不是静态方法不能直接调用，需要new一个实例才能调用
var a1 = new Asd()
a1.haox() // 不是静态方法不可以直接调用
```

### 6.继承

> 通过**extends**关键字继承。

```javascript
class A {

}
class B extends A {
  
}
```

* 子类中新添加的方法是添加到了子类的原型对象上，并不是父类的远程对象上;

```javascript
class A {
  constructor(name,age) {
    this.name = name
    this.age = age
  }
  eatting() {
    console.log(this.name + "吃！");
  }
  running() {
    console.log(this.name + "跑！");
  }
}
class B extends A {
  constructor(name,age,height) {
    // this.name = name
    // this.age = age
    super(name,age) // 这里必须调用父类的构造器否则报错(派生类的构造函数必须包含 "super" 调用。)，同时可以避免代码冗余
    this.height = height

  }
  study() {
    console.log("study");
  }
}

// 子类中新添加的方法是添加到了子类的原型对象上，并不是父类的远程对象上
console.log(Object.getOwnPropertyDescriptors(B.prototype)); // 输出如下：
// {
//   constructor: {
//     value: [class B extends A],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   study: {
//     value: [Function: study],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
console.log(Object.getOwnPropertyDescriptors(A.prototype));  // 输出如下：
// {
//   constructor: {
//     value: [class A],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   eatting: {
//     value: [Function: eatting],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   },
//   running: {
//     value: [Function: running],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// }
```



### 7.super关键字

> * 可调用父类的构造函数；
> * 可调用父类上的方法



## 二、字面量的增强

>  ES6中对 **对象**字面量 进行了增强;

### 1.属性的简写

### 2.方法的简写

### 3.计算属性名

```javascript
var age = 18
var obj1 = {
  // age : age
  age,    // 1.属性的简写

  // 2.方法名简写
  // foo: function() {

  // }
  foo() {  // 简写

  },

  // 3.计算属性
  [age + 123]: 'hhhhh',
  [age + '123']: 'hhhhh'
}

console.log(obj1);  // { '141': 'hhhhh', '18123': 'hhhhh', age: 18, foo: [Function: foo] }
```



## 三、解构赋值

### 1.数组的解构

```javascript
// 1.数组的解构
var names = ['agc', 'cag', 'asd']
var [item1, item2, item3] = names
console.log(item1,item2,item3); // agc cag asd

// 2.解构后面元素
var [, itema, itemb] = names
console.log(itema,itemb); // cag asd

// 3.解构出一个元素，后面的元素放到一个新数组中
var [itemx, ...newNames] = names
console.log(newNames); // [ 'cag', 'asd' ]

// 4.解构的默认值 (当解构的元素可能没有值时，可以设置一个默认值)
var [itema, itemb, itemc, itemd = 'aaa'] = names
console.log(itemd); // aaa
```

### 2.对象的解构

```javascript
var obj = {
  name: 'tjx',
  age: 39,
  height: 12,
  a: 12
}

// 1.对象的解构
var { namea, age, height } = obj
console.log(namea, age, height); // tjx 39 12

var { a } = obj
console.log(a); // 12

// 2.解构重命名
var {name: newName} = obj
console.log(newName); // tjx

// 3.解构重命名并给默认值
var { address: newAddress = "广州" } = obj  
console.log(newAddress); // 广州
```



## 四、var、const、let

> * **let和const**，是目前开发中推荐使用的；
>
> * 优先推荐使用const，这样可以保证数据的安全性不会被随意的篡改； 
> * 只有当明确知道一个变量后续会需要被重新赋值时，这个时候再使用let；

### 1.var

> * 作用域提升；
> * 函数有块级作用域，在函数中var变量属于该函数的局部变量；

### 2.const

> const关键字是constant的单词的缩写，表示常量、衡量的意思；
>
> 它表示保存的数据一旦被赋值，就不能被修改；
>
> 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容；

### 3.let

> 声明的变量具有块级作用域的特征；





## 五、模板字符串

### 1.基本使用

```javascript
let agea = 9
const info = `age: ${agea *2}`
console.log(info); // age: 18

function doubleAge() {
  return agea * 2
}
const infoa = `age: ${doubleAge()}`
console.log(infoa); // age: 18
```

### 2.标签模板字符串

```javascript
// 第一个参数依然是模板字符串中整个字符串，只是被切割成多块，放到了一个数组中
// 第二个参数是模块字符串中，第一个${}，一次类推
function foo(m, n, x) {
  console.log(m,n, x, '..........');
}
const named = 'tjx'
const aged = 13

// 通过模板标签调用函数
foo`Hello${named}, world${aged},!`  //  [ 'Hello', ', world', ',!' ] tjx 13 ..........
```



## 六、函数的参数

### 1.函数的默认参数

```javascript
// 1.函数默认参数
function foo(m = 'aaa', n = 'bb') {
  console.log(m,n);
}
foo() // aaa bb
foo('dfs','fds') // dfs fds

// 对象参数和默认参数以及解构
// 写法一：
function printInfo({name, age} = {name: 'tjc', age: 19}) {
  console.log(name,age);
}
printInfo() // tjc 19
printInfo({name: 'lobe', age: 90}) // lobe 90

// 写法二：
function printInfo({name = 'tjx', age = 19} = {}) {
  console.log(name,age);
}
```

### 2.函数的剩余参数

```javascript
function foo(m,n,...args) {
  console.log(m,n); // 1 2
  console.log(args);  // [ 3, 4, 5, 6, 7 ]
  console.log(arguments);  //  [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5, '5': 6, '6': 7 }
}
foo(1,2,3,4,5,6,7)
```

### 3.箭头函数的补充

> * 箭头函数没有**prototype**，不能通过new关键字创建箭头函数；
> * 箭头函数没有**this**以及**arguments**



## 七、展开运算符

```javascript
const nameg = ['asd', 'dfg', 'sdfg']
const nameh = 'tjx'
const infog = {name: 'tjx', age: 19}

// 1.函数调用时
function foo(x, y, z) {
  console.log(x,y,z);
}

foo(...nameg) // asd dfg sdfg
foo(...nameh) // t j x

// 2.构造数组时
const newNameg = [...nameg, ...nameh]
console.log(newNameg); // [ 'asd', 'dfg', 'sdfg', 't', 'j', 'x' ]

// 3.构造对象字面量时
const objh = {...infog, address: 'guand'}
console.log(objh); // { name: 'tjx', age: 19, address: 'guand' }
```



## 八、数值的表示

```javascript
const num1 = 100 // 十进制
const num2 = 0b100 // 二进制
const num3 = 0o100 // 八进制
const num4 = 0x100 // 十六进制

console.log(num1, num2, num3, num4); // 100 4 64 256

// 大的数值的连接符
const num = 10_000_000_000_000
console.log(num); // 10000000000000
```



## 九、Symbol

> 在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突； 比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下， 很容易造成冲突，从而覆盖掉它内部的某个属性；**Symbol就是为了解决上面的问题，用来生成一个独一无二的值。**

### 1.Symbol的使用

* Symbol值是通过**Symbol函数**来生成的，生成后可以作为属性名； 在ES6中，**对象的属性名**可以使用**字符串**，也可以使用**Symbol值**；
* Symbol即使**多次创建值**，它们也是**不同**的：Symbol函数执行后每次创建出来的值都是独一无二的；
* 也可以在创建Symbol值的时候传入一个描述**description**：这个是（ES10）新增的特性；

```javascript
// 1.Symbol的基本使用
const symbol1 = Symbol()
const symbol2 = Symbol()
console.log(symbol1 === symbol2); // false

// 2.description描述符
const symbol3 = Symbol('aaa')
console.log(symbol3.description); // aaa

// 3.Symbol值最为key
// 3.1 在定义对象字面量时使用
const obj = {
  [symbol1]: 'abc',
  [symbol2]: 'dfa'
}
// 3.2 新增属性
obj[symbol3] = 'nab'
// 3.3 Object.defineProperty方式

const symbol4 = Symbol()
Object.defineProperty(obj, symbol4, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 'mag'
})
console.log(obj[symbol1], obj[symbol2], obj[symbol3], obj[symbol4]); // abc dfa nab mag
// 注意：不能通过 . 的方式获取 结果：undefined
console.log(obj.symbol1); // undefined

// 4.使用Symbol作为key的属性名，在遍历/Object.keys等中是获取不到这些symbol值，需要Object.getOwnPropertySymbols来获取所有Symbol的key
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
console.log(Object.getOwnPropertySymbols(obj)); // [ Symbol(), Symbol(), Symbol(aaa), Symbol() ]
const keys = Object.getOwnPropertySymbols(obj)
for (const sKey of keys) {
  console.log(obj[sKey]); // 输出如下：
                          // abc
                          // dfa
                          // nab
                          // mag
}

// 5.创建相同的Symbol   Symbol.for(key)/Symbol.keyFor(symbol)
const a = Symbol.for('aaa')
const b = Symbol.for('aaa')
console.log(a); // Symbol(aaa)
console.log(a === b); // true

const keya = Symbol.keyFor(a) // 获取aaa用于通过for()创建相同的symbol
console.log(keya); // aaa
const c = Symbol.for(keya)
console.log(a === c); // true
```





## 十、Set

### 1.Set的基本使用

> 在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap。

* Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是**元素不能重复**。
* **创建Set**我们需要通过**Set构造函数**（暂时没有字面量创建的方式）

```javascript
// 1.创建Set
const set = new Set();
set.add(10)
set.add(20)
set.add(30)
set.add({})
console.log(set); // Set(4) { 10, 20, 30, {} }  set中内容不能重复
set.add({})
console.log(set); // Set(6) { 10, 20, 30, {}, {} }  这里set存放的是地址，所以两个对象
var obj = {}
set.add(obj)
set.add(obj)
set.add(obj)
console.log(set); // Set(6) { 10, 20, 30, {}, {}, {} }

// 2.数组去重
const arr = [33, 10, 26, 30, 33, 26]
const arrSet = new Set(arr)
const newArr1 = Array.from(arrSet)
const newArr2 = [...arrSet] // set也支持展开运算符
console.log(newArr1); // [ 33, 10, 26, 30 ]
console.log(newArr2); // [ 33, 10, 26, 30 ]
```

### 2.Set的常见方法

**Set常见属性：**

* **size**：返回Set中的元素的个数；

**Set常见方法：**

* **add(value)**：添加某个元素，返回Set对象本身；
* **delete(value)**：从set中删除和这个值相等的元素，返回boolean类型；
* **has(value)**：判断set中是否存在某个元素，返回boolean类型； 
* **clear()**：清空set中所有的元素，没有返回值；
* **forEach(callback, [, thisArg])**：通过forEach遍历set；

**另外：**Set是支持for of的遍历的。

```javascript
const arr1 = [33, 10, 26, 30, 33, 26]
const arrSet1 = new Set(arr1)

// 1.set的属性 size
console.log(arrSet1.size); // 4

// 2.set的方法
arrSet1.add(1000)
console.log(arrSet1); // Set(5) { 33, 10, 26, 30, 1000 }

arrSet1.delete(1000) // 删除这里只能传入值，不是下标
console.log(arrSet1); // Set(4) { 33, 10, 26, 30 }

console.log(arrSet1.has(33)); // true 判断是否有这个值，返回布尔值

arrSet1.clear()
console.log(arrSet1); // Set(0) {}

// 遍历Set
const arr2 = [33, 10, 26, 30, 33, 26]
const arrSet2 = new Set(arr2)

arrSet2.forEach(item => {
  console.log(item);
})

for (const item of arrSet2) {
  console.log(item);
}
```

### 3.WeakSet

> 一般比较少用。

#### (1) Set与WeakSet的区别

* 区别一：WeakSet中**只能存放对象类型**，不能存放基本数据类型；
* 区别二：WeakSet对元素的引用是**弱引用**，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收；

```javascript
// 区别一：只能存放对象类型
let weakSet = new WeakSet()
// weakSet.add(10) // 报错

// 区别二：对对象是一个弱引用
let obj3 = {
  name: 'tjx'
}
weakSet.add(obj3) // 弱引用
console.log(weakSet); // WeakSet { <items unknown> }

const set3 = new Set()
set.add(obj3) // 强引用
```

#### (2) WeakSet常见方法

*  **add(value)**：添加某个元素，返回WeakSet对象本身；
* **delete(value)**：从WeakSet中删除和这个值相等的元素，返回boolean类型；
* **has(value)**：判断WeakSet中是否存在某个元素，返回boolean类型；

**注意：**WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。 所以存储到WeakSet中的对象是**没办法获取**的；



## 十一、Map

> 数据结构是Map，用于存储**映射关系**。
>
> **对象**存储映射关系**只能用字符串**（ES6新增了Symbol）作为属性名（key）;
>
> 某些情况下我们可能希望通过其他类型作为key，比如对象,这是我们可以使用**Map**。

### 1.Map的常用方法

* **size**：返回Map中元素的个数；
* **set(key, value)**：在Map中添加key、value，并且返回整个Map对象； 
* **get(key)**：根据key获取Map中的value； phas(key)：判断是否包括某一个key，返回Boolean类型； 
* **delete(key)**：根据key删除一个键值对，返回Boolean类型； 
* **clear()**：清空所有的元素；
* **forEach(callback, [, thisArg])**：通过forEach遍历Map；

**另外：**

*  Map也可以通过**for of**进行遍历。

```javascript
let obj4 = {
  name: 'tjx'
}, obj5 = {
  age: 12
}
// 1.map的创建
const map = new Map()
map.set(obj4, 'aaa')
map.set(obj5, 'bbb')
map.set(1, 'ccc')
console.log(map); // Map(3) { { name: 'tjx' } => 'aaa', { age: 12 } => 'bbb', 1 => 'ccc' }

// 2.map的常见属性和方法
console.log(map.size); // 3
map.set('tjx', 'ddd')
console.log(map); // 输出如下：
                              // Map(4) {
                              //   { name: 'tjx' } => 'aaa',
                              //   { age: 12 } => 'bbb',
                              //   1 => 'ccc',
                              //   'tjx' => 'ddd'
                              // }
console.log(map.get('tjx')); // ddd

console.log(map.has(1)); // true

map.delete('tjx')
console.log(map); // Map(3) { { name: 'tjx' } => 'aaa', { age: 12 } => 'bbb', 1 => 'ccc' }

// map.clear()
// console.log(map); // Map(0) {}

// 3.map的遍历
map.forEach((item, key) => {
  console.log(item, key); // 输出如下：
                          // aaa { name: 'tjx' }
                          // bbb { age: 12 }
                          // ccc 1
})

for(const item of map) {
  console.log(item);  // 输出如下：
                      // [ { name: 'tjx' }, 'aaa' ]
                      // [ { age: 12 }, 'bbb' ]
                      // [ 1, 'ccc' ]
}

for (const [key, value] of map) {
  console.log(key, value); // 输出如下：
                            // { name: 'tjx' } aaa
                            // { age: 12 } bbb
                            // 1 ccc
}
```

### 2.WeakMap

#### (1)Map与WeakMap的区别

* 区别一：WeakMap的key**只能使用对象**，不接受其他的类型作为key； 
* 区别二：WeakMap的key对对象想的引用是**弱引用**，如果没有其他引用引用这个对象，那么GC可以回收该对象；

#### (2)WeakMap的常用方法

* **set(key, value)**：在Map中添加key、value，并且返回整个Map对象； 
* **get(key)**：根据key获取Map中的value；
* **has(key)**：判断是否包括某一个key，返回Boolean类型；
* **delete(key)**：根据key删除一个键值对，返回Boolean类型；

#### (3)WeakMap的应用

> vue3响应式原理。

```javascript
// 引用场景（vue3响应式原理）
const obj1 = {
  name: 'tjx',
  age: 19
}
function obj1NameFn1() {
  console.log("obj1NameFn1被执行");
}
function obj1NameFn2() {
  console.log("obj1NameFn2被执行");
}
function obj1AgeFn1() {
  console.log("obj1AgeFn1被执行");
}
function obj1AgeFn2() {
  console.log("obj1AgeFn2被执行");
}

const obj3 = {
  name: 'aaa',
  age: 09
}
function obj3NameFn1() {
  console.log("obj3NameFn1被执行");
}
function obj3NameFn2() {
  console.log("obj3NameFn2被执行");
}

// 1.创建WealMap
const weakMap = new WeakMap()

// 2.收集依赖结构
// 2.1 对obj1收集的数据结构
const obj1Map = new Map()
obj1Map.set('name', [obj1NameFn1, obj1NameFn2])
obj1Map.set('age', [obj1AgeFn1, obj1AgeFn2])
weakMap.set(obj1, obj1Map)

// 3.如果obj1.name发生了变化
// Proxy/Object.definePoroperty
obj1.name = 'java'
const targetWeakMap = weakMap.get(obj1)
const fns = targetWeakMap.get('name')
fns.forEach(item => item())
```



# ES7

### 1.数组includes方法

> 在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 **indexOf** 获取结果，并且判断是否为 -1。 
>
> 在ES7中，我们可以通过**includes**来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true， 否则返回false。

```javascript
const arrays = ['aba', 'cag', 'aba', 'dca', NaN]
if (arrays.indexOf('aba') !== -1) {
  console.log("包含aba"); // 包含aba
}

// ES7
console.log(arrays.includes('aba')); // true
console.log(arrays.includes('aba', 3)); // false  第二个参数表示从第几个开始查找是否包含该元素

// includes与indexof的区别: indexOf不能查找NaN
console.log(arrays.indexOf(NaN)); // -1
console.log(arrays.includes(NaN)); // true
```

### 2.指数运算符

```javascript
const result = Math.pow(3,3)
const result2 = 3 ** 3
console.log(result, result2); // 27 27
```

