# Promise详解

## 一、Promise的基本使用

> * **Promise**是一个构造函数，原型对象上有then、catch等方法。
>
> * 在通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor 
>
> * * 这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject；
>   * 当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数； 
>   * 当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数；

```javascript
// 1.写法一：
const promise1 = new Promise((resolve, reject) => {
  console.log("这里的代码立即执行");
  resolve(); // 当执行resolve方式时，会立即执行then中的回调函数
  // reject(); // 当执行reject方法时， 会执行catch中的回调函数 
  // resolve 与 reject只能执行一个
  // 返回的时Promise对象
}).then(() => {
  console.log("成功的回调");
}).catch(() => {
  console.log("失败的回调");
})


// 2.写法二：
const promise2 = new Promise((resolve, reject) => {
  console.log("这里的代码立即执行！");
  // resolve(); 
  reject();
})

promise2.then(() => {
  console.log("成功的回调");
}).catch(() => {
  console.log("失败的回调");
})

// 3.写法三：
const promise3 = new Promise((resolve, reject) => {
  console.log("这里的代码立即执行！");
  // resolve(); 
  reject();
})

promise3.then(() => {
  console.log("成功的回调");
}, () => {
  console.log("失败的回调");
})
```

## 二、Pormise的三种状态

> Promise使用过程可以划分成三个状态： 
>
> * **待定（pending）**: 初始状态，既没有被兑现，也没有被拒绝；
> * * 当执行executor中的代码时，处于该状态； 
> * **已兑现（fulfilled）**: 意味着操作成功完成； 
> * * 执行了resolve时，处于该状态； 
> * **已拒绝（rejected）**: 意味着操作失败；
> * * 执行了reject时，处于该状态；

```javascript
// 注意: Promise状态一旦确定下来, 那么就是不可更改的(锁定)
new Promise((resolve, reject) => {
  // pending状态: 待定/悬而未决的
  console.log("--------")
  reject() // 处于rejected状态(已拒绝状态)
  resolve() // 处于fulfilled状态(已敲定/兑现状态)
  console.log("++++++++++++")
}).then(res => {
  console.log("res:", res)
}, err => {
  console.log("err:", err)
})
```

## 三、resolve的参数

### 1.传入普通的值或对象

> 如果resolve传入一个普通的值或者对象，那么这个值会作为then回调的参数；

### 2.传入一个Promise

> 如果resolve中传入的是另外一个Promise，那么这个新Promise会决定原Promise的状态;

### 3.传入实现了then的对象

> 如果resolve中传入的是一个对象，并且这个对象有实现then方法，那么会执行该then方法，并且根据 then方法的结果来决定Promise的状态;

```javascript
// 1.传入普通参数
const promise1 = new Promise((resolve, rejest) => {
  console.log("这里的代码立即执行");
  resolve("传入字符串");
})
promise1.then((res) => {
  console.log(res);
})

// 2.传入Promise
const promise2 = new Promise((resolve, rejest) => {
  console.log("aaaaaaaaaaaa");
  // 状态不是由这里决定的，而是由resolve中的Promise对象决定
  resolve(new Promise((resolve, rejest) => {
    rejest() // 这里决定状态
  }))
})
promise2.then((res) => {
  console.log(res);   // 执行的不是这里的代码
}, (err) => {
  console.log("err",err); // 执行的是这里的代码
})

// 3.传入实现了then的对象
const promise3 = new Promise((resolve, rejest) => {
  console.log("asdf");
  const obj = {
    // 实现then方法，这个方法中也是resolve和rejest参数
    then: (resolve, rejest) => {
      rejest("这里决定状态")
    }
  }
  resolve(obj) // 状态不是由这里决定，而是由传入的obj对象的then方法中的resolve和rejest决定
})
promise3.then((res) => {
  console.log("res", res);
}, (err) => {
  console.log("err", err); // err 这里决定状态  (执行这里的代码)
})
```



## 四、then方法

### 1.then的参数

> * then方法是Promise对象上的一个方法：它其实是放在Promise的原型上的 Promise.prototype.then
> * then方法接受两个参数： 
> * * resolve的回调函数：当状态变成fulfilled时会回调的函数； 
>   * reject的回调函数：当状态变成reject时会回调的函数；

```javascript
promise.then(res => {
  console.log("res", res);
}, err => {
  console.log("err", err);
})
// 等价于
promise.then(res => {
  console.log("res", res);
}).catch(err => {
  console.log("err", err);
})
```


### 2.then被多次调用

```javascript
// then方法多次调用 : 当then被多次调用时，每一个then中的回调函数都会被执行
// 所以一下代码会执行 3 次
const promisea = new Promise((resolve, rejest) => {
  resolve('aaaaaa')
})
promisea.then(res => {
  console.log("res1:", res);
})
promisea.then(res => {
  console.log("res2:", res);
})
promisea.then(res => {
  console.log("res3:", res);
})
```

### 3.then的返回值

> * 返回一个普通纸；
> * 返回一个Promise；
> * 返回一个实现了then方法的对象(即thenable值)；

```javascript

// then的返回值  then的返回值都是一个参数
// 1.返回一个普通值
// 当返回一个普通值时,这个普通值会被最为新new的Promise的resolve的参数,所以then返回的是一个Promise
const promisea = new Promise((resolve, rejest) => {
  resolve("aaa")
})
promisea.then(res => { // 这里的第一个then方法是promisea的then方法
  return "bbb" // 相当于: new Promise((resolve,rejest) => {resolve('aaa)}) 即这个普通值会被作为新的Promise的resolve值
}).then(res => { // 这里的第二个then是第二个Promise(即 new Promise((resolve,rejest) => {resolve('aaa)}) )的then方法,而不是promisea的then方法
  console.log(res); // bbb
  // 当然这里还可以有返回值
})

// 2.返回值是一个Promise对象时
const promiseb = new Promise((resolve, rejest) => {
  resolve('aaa')
})
promiseb.then(res => { // 这里的then方法是promiseb的then方法
  return new Promise((resolve, rejest) => {
    setTimeout(() => {
      resolve('bbb')
    }, 3000)
  })
}).then(res => { // 这里的then也是new的新的Promise的then方法,而不是promiseb的
  console.log(res); // 三秒后输出  bbb
})

// 3.当返回值是一个实现了then方法的对象时
const promisec = new Promise((resolve, rejest) => {
  resolve('aaa')
})
promiseb.then(res => { // 这里的then方法是promiseb的then方法
  const obj = {
    then: function(resolve, rejest) {
      resolve('bbb')
    }
  }
  return obj  // 新的promise的状态有obj对象里的resolve或reject决定
}).then(res => {
  console.log(res); // bbb
})
```

