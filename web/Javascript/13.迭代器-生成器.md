## 迭代器

### 1.什么是迭代器

> 迭代器是帮助我们对某个数据结构**进行遍历的对象**。
>
> 在JavaScript中，迭代器也是一个具体的对象，这个对象需要符合迭代器协议，那么在js中这个标准就是一个特定的**next方法**；

**next方法有如下要求：**

* **next方法**是一个有**一个**参数或**无**参数的函数，该函数**返回**一个拥有以下两个属性的**对象**；
* **done（boolean）：**
* * 如果迭代器可以产生序列中的下一个值，则为 false。（这等价于没有指定 done 这个属性。） 
  * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。
* **value：**
* * 迭代器返回的任何 JavaScript 值。done 为 true 时可省略。

**编写一个符合规则的迭代器：**

```javascript
// 编写一个符合规则的迭代器
const iterator = {
  next: function() {
    return { // 返回一个拥有这两个属性的对象
      done: true, 
      value: 123
    }
  }
}
```



### 2.迭代器的基本使用

**创建一个迭代器对象来访问数组：**

```javascript
// 数组
const names = ['a', 'b', 'c', 'd']
// 用于记录遍历时的下标
let index = 0
// 创建一个迭代器对象来访问数组
const namesIterator = {
  next: function() {
    if (index < names.length) {
      return { done: false, value: names[index++]}
    } else {
      return { done: true, vlaue: undefined}
    }
  }
}
console.log(namesIterator.next());  // { done: false, value: 'a' }
console.log(namesIterator.next());  // { done: false, value: 'b' }
console.log(namesIterator.next());  // { done: false, value: 'c' }
console.log(namesIterator.next());  // { done: false, value: 'd' }
console.log(namesIterator.next());  // { done: true, vlaue: undefined }
console.log(namesIterator.next());  // { done: true, vlaue: undefined }
```

**封装一个迭代器函数：**

```javascript
function createArrayIterator(arr) {
  let index = 0;
  return {
    next: function() {
      if (index < arr.length) {
        return { done: false, value: arr[index++]}
      } else {
        return { done: true, value: undefined}
      }
    }
  }
}

const namea = ['a', 'b', 'c']
const ages = [1, 2, 3]

const nameaIterator = createArrayIterator(namea)
const agesIterator = createArrayIterator(ages)

console.log(nameaIterator.next()); // { done: false, value: 'a' }
console.log(nameaIterator.next()); // { done: false, value: 'b' }
console.log(nameaIterator.next()); // { done: false, value: 'c' }
console.log(nameaIterator.next()); // { done: true, value: undefined }

console.log(agesIterator.next());  // { done: false, value: 1 }
console.log(agesIterator.next());  // { done: false, value: 2 }
console.log(agesIterator.next());  // { done: false, value: 3 }
console.log(agesIterator.next());  // { done: true, value: undefined }
```



### 3.可迭代对象

> 可迭代对象的要求是必须实现 **@@iterator 方法**，在代码中我们使用 **Symbol.iterator** 访问该属性，实现了该方法的对象为**可迭代对象**；
>
> 当一个对象变成一个可迭代对象的时候，进行某些迭代操作，比如 **for...of** 操作时，其实就会调用它的 **@@iterator 方法**；

```javascript
// 创建一个可迭代对象
const iterableObj = {
  names: ['a', 'b', 'c'],
  [Symbol.iterator]: function() {
    let index = 0
    return {
      next: () => { // 这里必须是箭头函数: 为了this的指向iterableObj对象，而不是return的迭代器对象
        if (index < this.names.length) {
          return { done: false, value: this.names[index++]}
        } else {
          return { done: true, value: undefined}
        }
      }
    }
  }
}
console.log(iterableObj[Symbol.iterator]); // [Function: [Symbol.iterator]]

// 每次调用iterableObj[Symbol.iterator]()函数都是独立的，一次调用的next不会影响另一此调用的next
const iterator1 = iterableObj[Symbol.iterator]() // 这里必须要有 () ，这样才是调用这个函数
console.log(iterator1.next()); // { done: false, value: 'a' }
console.log(iterator1.next()); // { done: false, value: 'b' }
console.log(iterator1.next()); // { done: false, value: 'c' }
console.log(iterator1.next()); // { done: false, value: undefined }
// 第二此调用
const iterator2 = iterableObj[Symbol.iterator]() // 这里必须要有 () ，这样才是调用这个函数
console.log(iterator2.next()); // { done: false, value: 'a' }
console.log(iterator2.next()); // { done: false, value: 'b' }
console.log(iterator2.next()); // { done: false, value: 'c' }
console.log(iterator2.next()); // { done: false, value: undefined }

// for of 就是调用了iterableObj的iterableObj[Symbol.iterator]()函数
for (const item of iterableObj) {
  console.log(item);
}
```



### 4.内置可迭代对象

> 事实上我们平时创建的很多原生对象已经实现了可迭代协议，会生成一个迭代器对象的： 
>
> **String**、**Array**、**Map**、**Set**、**arguments对象**、**NodeList集合**；

```javascript
// String、Array、Map、Set、arguments对象、NodeList集合是可迭代对象，他们内置了迭代器
// 如字符串就是一个可迭代对象
const strings = 'abc'
// 获取可迭代的函数
console.log(strings[Symbol.iterator]); // [Function: [Symbol.iterator]]
// 调用可迭代函数， 获取迭代器
const iteratorString = strings[Symbol.iterator]() // 别忘了这里的()，调用可迭代函数
console.log(iteratorString.next()); // { value: 'a', done: false }
console.log(iteratorString.next()); // { value: 'b', done: false }
console.log(iteratorString.next()); // { value: 'c', done: false }
console.log(iteratorString.next()); // { value: undefined, done: false }
```



### 5.可迭代对象的应用

> *  JavaScript中语法：for ...of、展开语法（spread syntax）、yield*（后面讲）、解构赋值（Destructuring_assignment）； 
> * 创建一些对象时：new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable]); 
> * 一些方法的调用：Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable);

```javascript
// 1.for of场景

// 2.展开语法(spread syntax)
const iterableObj = {
  names: ["abc", "cba", "nba"],
  [Symbol.iterator]: function() {
    let index = 0
    return {
      next: () => {
        if (index < this.names.length) {
          return { done: false, value: this.names[index++] }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
}

const names = ["abc", "cba", "nba"]
const newNames = [...names, ...iterableObj]
console.log(newNames)

const obj = { name: "why", age: 18 }
// for (const item of obj) {
// }
// ES9(ES2018)中新增的一个特性: 用的不是迭代器
const newObj = { ...obj } // 由于对象没有可迭代器，所以这里不是可迭代对象的应用
console.log(newObj)


// 3.解构语法
const [ name1, name2 ] = names
// const { name, age } = obj 不一样ES9新增的特性

// 4.创建一些其他对象时
const set1 = new Set(iterableObj)
const set2 = new Set(names)
const arr1 = Array.from(iterableObj)

// 5.Promise.all
Promise.all(iterableObj).then(res => {
  console.log(res)
})
```

