# 知识点

## 一、小知识点

### 1.动态组件

> **动态组件**是使用 **component 组件**，通过一个特殊的attribute **is** 来实现.
>
> 动态组件**传值**通过**props**进行传值。

```javascript
<template>
  <div>
    <button
      v-for="item in tabs"
      :key="item"
      @click="itemClick(item)"
      :class="{ active: currentTab === item }"
    >
      {{ item }}
    </button>


    <!-- 2.动态组件 -->
    <!-- currentTab的值为components注册的组件，该组件需要设置name值 -->
    <component :is="currentTab"></component>
    <!-- 动态组件传值：通过props进行传递，然后home,about等组件通过props接受 -->
    <component
      :is="currentTab"
      name="tjx"
      :age="18"
      @pageClick="pageaClick"
    ></component>

  </div>
</template>

<script>
import Home from "./pages/Home.vue";
import Category from "./pages/Category.vue";
import About from "./pages/About.vue";
export default {
  data() {
    return {
      tabs: ["home", "about", "category"],
      currentTab: "home",
    };
  },
  methods: {
    itemClick(item) {
      this.currentTab = item;
    },
    pageaClick() {
      console.log("page内部发生点击");
    },
  },
  components: {
    Home,
    Category,
    About,
  },
};
</script>
```



### 2.keep-alive

> 在开发中某些情况我们希望继续**保持组件的状态**，而不是销毁掉，这个时候我们就可以使用一个内置组件： **keep-alive**。

**keep-alive属性：**

* **include** - string | RegExp | Array。只有名称匹配的组件会被缓存；
* **exclude** - string | RegExp | Array。任何名称匹配的组件都不 会被缓存；
* **max** - number | string。最多可以缓存多少组件实例，一旦达 到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；

**注：**include 和 exclude prop 允许组件有条件地缓存：二者都可以用逗号分隔字符串、正则表达式或一个数组来表示；匹配首先检查组件自身的 name 选项；

```javascript
<!-- keep-alive -->
    <keep-alive include="about,home"
      ><component
        :is="currentTab"
        name="tjx"
        :age="18"
        @pageClick="pageaClick"
      ></component
    ></keep-alive>
```

### 3.缓存组件的生命周期

> 对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的： 但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件； 这个时候我们可以使用**activated** 和 **deactivated** 这两个生命周期钩子函数来监听；

### 4.Webpack的代码分包

> 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组件模块打包到一起（比如一个app.js文件中）； 这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢；
>
> 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js；这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容；那么webpack中如何可以对代码进行分包呢?

![image-20220704213415631](D:\Typora笔记\web\Vue3\知识点\img\webpack代码分包.png)

### 5.Vue中实现异步组件

> 项目过大了，对于某些组件我们希望通过异步的方式来进行加载（目的是可以对其进行分包处理），那 么Vue中给我们提供了一个函数：**defineAsyncComponent**。

**defineAsyncComponent接受两种类型的参数：**

* 类型一：工厂函数，该工厂函数需要返回一个Promise对象；
* 类型二：接受一个对象类型，对异步函数进行配置；

```javascript
<template>
  <div>
    <suspene>
      <template #defautl>
        <async-category></async-category>
      </template>
      <template #fallback>
        <loading></loading>
      </template>
    </suspene>
  </div>
</template>

<script>
import {defineAsyncComponent} from 'vue'
import Loading from "./utils/Loading.vue"

// import AsyncCategory from "./utils/AsyncCategory.vue"
// 写法一：
const AsyncCategory = defineAsyncComponent(() => import('./utils/AsyncCategory.vue'))
// 写法二：
  // const AsyncCategory = defineAsyncComponent({
  //   loader: () => import('./utils/AsyncCategory.vue'),
  //   // 当AsyncCategory还未加载下来时，使用Loading组件占位
  //   loadingComponent: Loading,
  //   // 加载失败时显示这个组件
  //   errorComponent: Loading,
  //   // 延迟 显示loading组件之前，等待多长事件
  //   delay: 2000,
  //   // err:错误信息 retry:函数，调用retry尝试重新加载 attempts：记录尝试的次数
  //   // onError: function(err, retry, attempts) {

  //   // }
  // })

  export default {
    components: {
      AsyncCategory,
      Loading
    }
  }
</script>
```

### 6.异步组件和Suspense

> Suspense是一个内置的全局组件，该组件有两个插槽：
>
> * default：如果default可以显示，那么显示default的内容；
> * fallback：如果default无法显示，那么会显示fallback插槽的内容；

```html
<template>
  <div>
    <suspene>
      <template #defautl>
        <async-category></async-category>
      </template>
      <template #fallback>
        <loading></loading>
      </template>
    </suspene>
  </div>
</template>
```

### 7.$refs的使用

```javascript
<template>
  <div>
    <h2 ref="haha">haha</h2>
    <button @click="btnClick">get</button>
    <nav-bar ref="navBar"></nav-bar>
  </div>
</template>

<script>
import NavBar from "./NavBar.vue"
  export default {
    components: {
      NavBar
    },
    data() {
      return {
        names: ['abc','csb']
      }
    },
    methods: {
      btnClick() {
        console.log(this.$refs.haha);
        console.log(this.$refs.navBar.message);
        this.$refs.navBar.sayHello();
      }
    }
  }
</script>
```

### 8.组件的v-model

 **App.vue：**

```javascript
<template>
  <div>
    <!-- <input type="text" v-model="message"> -->

    <!-- 组件上使用v-model -->
    <!-- <tjx-input v-model="message"></tjx-input> -->
    <!-- <tjx-input :modelValue="message" @update:model-value="message = $event"></tjx-input> -->

    <!-- 绑定两个v-model -->
    <tjx-input v-model="message" v-model:title="title"></tjx-input>

    <h1>{{message}}</h1>
    <h2>{{title}}</h2>

    
  </div>
</template>

<script>
import TjxInput from "./TjxInput.vue"
  export default {
    data() {
      return {
        message: "hello world",
        title: "dsfsd"
      }
    },
    components: {
      TjxInput
    }
  }
</script>
```

**TjxInput.vue：**

```javascript
<template>
  <div>
    <input type="text" v-model="value" />
    <input type="text" v-model="titles" />
  </div>
</template>

<script>
export default {
  props: {
    modelValue: String,
    title: String,
  },
  emits: ["update:modelValue", "update:title"],
  computed: {
    value: {
      set(value) {
        this.$emit("update:modelValue", value);
      },
      get() {
        return this.modelValue;
      },
    },
    titles: {
      set(titles) {
        this.$emit("update:title", titles);
      },
      get() {
        return this.title;
      },
    },
  },
};
</script>
```







## 二、动画

> 想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验：
>
> **React**框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group；
>
> **Vue**中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果；

### 1.Vue的transition动画

> Vue 提供了 **transition** 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡：
>
> **条件渲染** (使用 v-if)条件展示 (使用 v-show) 
>
> **动态组件** 
>
> **组件根节点**

#### (1)transition执行过程

**当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：**

* 自动嗅探目标元素是否应用了CSS过渡或者动画，如果有，那么在恰当的时机添加/删除 CSS类名；
* 如果 transition 组件提供了**JavaScript钩子函数**，这些钩子函数将在恰当的时机被调用；
* 如果没有找到JavaScript钩子并且也没有检测到CSS过渡/动画，DOM插入、删除操作将会立即执行；

#### (2)过渡动画class

* **v-enter-from**：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。
* **v-enter-active**：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动 画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 
* **v-enter-to**：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/ 动画完成之后移除。
* **v-leave-from**：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。
* **v-leave-active**：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在 过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。
* **v-leave-to**：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/ 动画完成之后移除。

**class的name命名规则如下**：

* 如果我们使用的是一个没有name的transition，那么所有的class是以 v- 作为默认前缀；
* 如果我们添加了一个name属性，比如 ，那么所有的class会以 why- 开头；

![image-20220705174935786](D:\Typora笔记\web\Vue3\知识点\img\动画.png)

```javascript
<template>
  <div>
    <button @click="isShow = !isShow">显示与隐藏</button>
    <transition name="tjx">
      <h2 v-if="isShow">hello world</h2>
    </transition>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        isShow: true
      }
    }
  }
</script>

<style scoped>
.tjx-enter-from,
.tjx-leave-to {
  opacity: 0;
}

.tjx-enter-to,
.tjx-leave-from {
  opacity: 1;
}

.tjx-enter-active,
.tjx-leave-active {
  transition: opacity 2s ease;
}
</style>
```

#### (3)animation实现动画

> 通过**transition**来实现的动画效果，另外我们也可以通过**animation**来实现。

```javascript
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <transition name="tjx">
      <h2 v-if="isShow" class="title">hello world</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
};
</script>

<style scoped>
.title {
  display: inline-block;
}
.tjx-enter-active {
  animation: bounce 1s ease;
}
.tjx-leave-active {
  animation: bounce 1s ease reverse;
}
@keyframes bounce {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```

#### (4)同时设置transition和animation动画

> Vue为了知道过渡的完成，内部是在监听 transitionend 或 animationend，到底使用哪一个取决于元素应用的 CSS规则： 如果我们只是使用了其中的一个，那么Vue能自动识别类型并设置监听；
>
> 但是如果我们同时使用了过渡和动画呢？ 并且在这个情况下可能某一个动画执行结束时，另外一个动画还没有结束；在这种情况下，我们可以设置 **type** 属性为 **animation** 或者 **transition** 来明确的告知Vue**监听的类型**；

#### (5)显示指定动画时间

> 可以显示的来指定过渡的时间，通过 **duration** 属性。 
>
> **duration**可以设置两种类型的值：
>
> **number**类型：同时设置进入和离开的过渡时间； 
>
> **object**类型：分别设置进入和离开的过渡时间；

```javascript
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <!-- 根据type的值决定根据哪个动画来决定结束 -->
    <!-- duration:决定动画的事件 -->
    <transition name="tjx" type="transition" :duration="1000">
      <h2 v-if="isShow" class="title">hello world</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
};
</script>

<style scoped>
.title {
  display: inline-block;
}

.tjx-enter-from,
.tjx-leave-to {
  opacity: 0;
}

.tjx-enter-active,
.tjx-leave-active {
  transition: opacity 2s ease;
}

.tjx-enter-active {
  animation: bounce 1s ease;
}
.tjx-leave-active {
  animation: bounce 1s ease reverse;
}
@keyframes bounce {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```

#### (6)过渡的模式mode

> 是如果我们不希望同时执行进入和离开动画，那么我们需要设置**transition**的过渡模式： 
>
> **in-out**: 新元素先进行过渡，完成之后当前元素过渡离开；
>
> **out-in**: 当前元素先进行过渡，完成之后新元素过渡进入；

```javascript
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <transition name="tjx" mode="in-out">
      <h2 v-if="isShow" class="title">hello world</h2>
      <h2 v-else class="title">hello yn</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
};
</script>

<style scoped>
.title {
  display: inline-block;
}

.tjx-enter-from,
.tjx-leave-to {
  opacity: 0;
}

.tjx-enter-active,
.tjx-leave-active {
  transition: opacity 2s ease;
}

.tjx-enter-active {
  animation: bounce 1s ease;
}
.tjx-leave-active {
  animation: bounce 1s ease reverse;
}
@keyframes bounce {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}
</style>
```

#### (7)appear初次渲染

> 默认情况下，首次渲染的时候是没有动画的，如果我们希望给他添加上去动画，那么就可以增加另外一个属性 **appear**

```javascript
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <!-- appear:刚开始就进行一次动画 -->
    <transition name="tjx" mode="out-in" :appear="true">
      <component :is="isShow ? 'home' : 'about'"></component>
    </transition>
  </div>
</template>

```



### 2.animate.css

> 如何使用Animate库呢？ 
>
> 第一步：需要安装animate.css库：**npm install animate.css**
>
> 第二步：导入animate.css库的样式：import "animate.css"
>
> 第三步：使用animation动画或者animate提供的类；

* 用法一：直接使用animate库中定义的 **keyframes** 动画；
* 用法二：直接使用animate库提供给我们的**类**；

```html
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <transition enter-active-class="animate__animated animate__fadeInDown" leave-active-class="animate__animated animate__flipInY">
      <h2 class="title" v-if="isShow">heoodfsls</h2>
    </transition>
  </div>
</template>
```



### 3.gsap库

> 通过JavaScript来实现一些动画的效果，这个时候我们可以选择使用gsap库来完成。
>
> 第一步：需要安装gsap库：**npm install gsap**
>
> 第二步：导入gsap库；
>
> 第三步：使用对应的api即可；

#### (1)JavaScript钩子

> 在使用动画之前，我们先来看一下transition组件给我们提供的JavaScript钩子，这些钩子可以帮助我们监听动画执行到 什么阶段了

```javascript
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <transition @before-enter="beforeEnter"
                @enter="enter"
                @after-enter="afterEnter"
                @before-leave="beforeLeave"
                @leave="leave"
                @afterLeave="afterLeave">
      <h2 class="title" v-if="isShow">heoodfsls</h2>
    </transition>
  </div>
</template>

<script>
export default {
  data() {
    return {
      isShow: true,
    };
  },
  methods: {
    beforeEnter() {
      console.log("beforeEnter");
    },
    enter() {
      console.log("enter");
    },
    afterEnter() {
      console.log("afterEnter");
    },
    beforeLeave() {
      console.log("beforeLeave");
    },
    leave() {
      console.log("leave");
    },
    afterLeave() {
      console.log("afterLeave");
    }
  }
};
</script>

<style scoped>
.title {
  display: inline-block;
}

</style>
```

* 当我们使用JavaScript来执行过渡动画时，需要进行 done 回调，否则它们将会被同步调用，过渡会立即完成。 
* 添加 **:css="false"**，也会让 Vue 会跳过 CSS 的检测，除了性能略高之外，这可以避免过渡过程中 CSS 规则的影响。

#### (2)gsap库的使用

```javascript
<template>
  <div>
    <div><button @click="isShow = !isShow">显示与隐藏</button></div>

    <!-- :css="false" 不再执行css动画 -->
    <transition @enter="enter" @leave="leave" :css="false">
      <h2 class="title" v-if="isShow">heoodfsls</h2>
    </transition>
  </div>
</template>

<script>
import gsap from "gsap";
export default {
  data() {
    return {
      isShow: true,
    };
  },
  methods: {
    enter(element, done) {
      console.log("enter");
      // gsap.to(element, {})
      gsap.from(element, {
        scale: 0,
        x: 200, // translateX:200px
        onComplete: done,
      });
    },
    leave(element, done) {
      console.log("leave");
      gsap.to(element, {
        scale: 0,
        x: 200, // translateX:200px
        onComplete: done,
      });
    },
  },
};
</script>

<style scoped>
.title {
  display: inline-block;
}
</style>
```

#### (3)gsap实现数字变化

```javascript
<template>
  <div class="app">
    <input type="number" step="100" v-model="counter">
    <h2>{{showCounter}}</h2>
  </div>
</template>

<script>
import gsap from "gsap";
export default {
  data() {
    return {
      counter: 0,
      showNumber: 0
    };
  },
  computed: {
    showCounter() {
      return this.showNumber.toFixed(0)
    }
  },
  watch: {
    counter(newValue) {
      gsap.to(this, {
        duration: 1,
        showNumber: newValue
      })
    }
  }
};
</script>

<style scoped>
.title {
  display: inline-block;
}
</style>
```



### 4.列表的过渡

> 望渲染一个列表，并且该列表中添加删除数据也希望有动画执行呢？ 这个时候我们要使用  `<transition-group>`组件来完成；

**使用 有如下的特点**： 

* 默认情况下，它不会渲染一个元素的包裹器，但是你可以指定一个元素并以 tag attribute 进行渲染；
* 过渡模式不可用，因为我们不再相互切换特有的元素；
* 内部元素总是需要提供唯一的 key attribute 值；
* CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身；

#### (1)列表过渡的移动动画

> 中虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：
>
> 我们可以通过使用一个新增的 v-move 的class来完成动画；
>
> 它会在元素改变位置的过程中应用； 
>
> 像之前的名字一样，我们可以通过name来自定义前缀；

```javascript
<template>
  <div>
    <button @click="addNum">添加数字</button>
    <button @click="removeNum">删除数字</button>

    <transition-group tag="p" name="tjx">
      <span v-for="item in numbers" :key="item" class="item">{{item}}</span>
    </transition-group>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
        numCounter: 10
      }
    },
    methods: {
      addNum() {
        this.numbers.splice(this.randomIndex(), 0, this.numCounter++)
      },
      removeNum() {
         this.numbers.splice(this.randomIndex(), 1)
      },
      randomIndex() {
        return Math.floor(Math.random() * this.numbers.length)
      }
    }
  }
</script>

<style scoped>
.item {
  margin-right: 10px;
}

.tjx-enter-from,
.tjx-leave-to {
  opacity: 0;
  transform: translateY(30px);
}

.tjx-enter-active,
.tjx-leave-avtive {
  transition: all 1s ease;
}

.tjx-leave-avtive {
  position: absolute;
}

.tjx-move {
  transition: transform 1s ease;
}

</style>
```

